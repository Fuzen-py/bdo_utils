pub struct ProcessingMastery;
const MasteryPairs: [[u32; 2]; 66] = [
    [2, 10],
    [20, 11],
    [40, 12],
    [60, 13],
    [80, 14],
    [100, 15],
    [120, 16],
    [140, 17],
    [160, 18],
    [180, 19],
    [200, 20],
    [220, 21],
    [240, 22],
    [260, 23],
    [280, 24],
    [300, 25],
    [320, 26],
    [340, 27],
    [360, 28],
    [380, 29],
    [400, 30],
    [420, 31],
    [440, 32],
    [460, 33],
    [380, 34],
    [500, 35],
    [520, 36],
    [540, 37],
    [560, 38],
    [580, 39],
    [600, 40],
    [620, 41],
    [640, 42],
    [660, 43],
    [680, 45],
    [700, 47],
    [720, 49],
    [740, 51],
    [460, 53],
    [580, 57],
    [810, 60],
    [840, 64],
    [870, 68],
    [900, 72],
    [930, 76],
    [960, 80],
    [990, 85],
    [1020, 90],
    [1060, 96],
    [1100, 112],
    [1140, 118],
    [1180, 124],
    [1220, 130],
    [1260, 137],
    [1300, 144],
    [1350, 157],
    [1400, 162],
    [1450, 170],
    [1500, 178],
    [1550, 186],
    [1600, 194],
    [1650, 203],
    [1700, 212],
    [1800, 222],
    [1900, 235],
    [2000, 250],
];

impl ProcessingMastery {
    pub fn batch_process(mastery: u32) -> u32 {
        let mut m: Vec<[u32; 2]> = MasteryPairs
            .iter()
            .filter_map(|pair| {
                if let Some(n) = pair[0].checked_sub(mastery) {
                    Some([n, pair[1]])
                } else {
                    None
                }
            })
            .collect();
        if m.is_empty() {
            MasteryPairs.last().unwrap()[1]
        } else {
            m.sort_by(|a, b| a[0].partial_cmp(&b[0]).unwrap());
            m.first().unwrap()[1]
        }
    }
    // TODO: Implement a caculator for profit gained from processing
}
